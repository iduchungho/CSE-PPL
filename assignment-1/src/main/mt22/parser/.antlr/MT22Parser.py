# Generated from c:\Users\84865\Documents\BK-CSE20\CSE-PPL\assignment-1\src\main\mt22\parser\MT22.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\60")
        buf.write("\u00a1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\3\2\6\2.\n\2\r\2\16\2/")
        buf.write("\3\2\3\2\3\3\3\3\3\3\5\3\67\n\3\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\5\3\5\3\6\3\6\5\6D\n\6\3\7\3\7\3\7\3\7\5\7J\n")
        buf.write("\7\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3\n\3\n")
        buf.write("\3\n\5\nZ\n\n\3\13\3\13\3\13\3\13\5\13`\n\13\3\f\3\f\5")
        buf.write("\fd\n\f\3\r\3\r\3\r\3\r\5\rj\n\r\3\16\3\16\3\16\3\16\5")
        buf.write("\16p\n\16\3\17\3\17\3\17\3\17\5\17v\n\17\3\20\3\20\5\20")
        buf.write("z\n\20\3\20\3\20\5\20~\n\20\3\20\3\20\3\20\3\20\3\21\3")
        buf.write("\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\22\3\22\3\22")
        buf.write("\5\22\u0090\n\22\3\23\3\23\3\24\3\24\5\24\u0096\n\24\3")
        buf.write("\25\3\25\3\25\3\25\3\25\5\25\u009d\n\25\3\26\3\26\3\26")
        buf.write("\2\2\27\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*")
        buf.write("\2\4\6\2\13\13\16\16\21\21\23\23\7\2\t\t\13\f\16\16\21")
        buf.write("\21\23\23\2\u009b\2-\3\2\2\2\4\66\3\2\2\2\68\3\2\2\2\b")
        buf.write("?\3\2\2\2\nC\3\2\2\2\fI\3\2\2\2\16K\3\2\2\2\20P\3\2\2")
        buf.write("\2\22Y\3\2\2\2\24_\3\2\2\2\26c\3\2\2\2\30i\3\2\2\2\32")
        buf.write("o\3\2\2\2\34u\3\2\2\2\36y\3\2\2\2 \u0083\3\2\2\2\"\u008f")
        buf.write("\3\2\2\2$\u0091\3\2\2\2&\u0095\3\2\2\2(\u009c\3\2\2\2")
        buf.write("*\u009e\3\2\2\2,.\5\4\3\2-,\3\2\2\2./\3\2\2\2/-\3\2\2")
        buf.write("\2/\60\3\2\2\2\60\61\3\2\2\2\61\62\7\2\2\3\62\3\3\2\2")
        buf.write("\2\63\67\5\6\4\2\64\67\5\20\t\2\65\67\5 \21\2\66\63\3")
        buf.write("\2\2\2\66\64\3\2\2\2\66\65\3\2\2\2\67\5\3\2\2\289\7\r")
        buf.write("\2\29:\7(\2\2:;\5\n\6\2;<\7)\2\2<=\7\27\2\2=>\5\b\5\2")
        buf.write(">\7\3\2\2\2?@\t\2\2\2@\t\3\2\2\2AD\5\f\7\2BD\5\16\b\2")
        buf.write("CA\3\2\2\2CB\3\2\2\2D\13\3\2\2\2EF\7\4\2\2FG\7\"\2\2G")
        buf.write("J\5\f\7\2HJ\7\4\2\2IE\3\2\2\2IH\3\2\2\2J\r\3\2\2\2KL\7")
        buf.write("\5\2\2LM\7\"\2\2MN\5\16\b\2NO\7\5\2\2O\17\3\2\2\2PQ\5")
        buf.write("\24\13\2QR\7%\2\2RS\5\b\5\2ST\5\22\n\2TU\7#\2\2U\21\3")
        buf.write("\2\2\2VW\7$\2\2WZ\5\26\f\2XZ\3\2\2\2YV\3\2\2\2YX\3\2\2")
        buf.write("\2Z\23\3\2\2\2[\\\7,\2\2\\]\7\"\2\2]`\5\24\13\2^`\7,\2")
        buf.write("\2_[\3\2\2\2_^\3\2\2\2`\25\3\2\2\2ad\5\30\r\2bd\5\32\16")
        buf.write("\2ca\3\2\2\2cb\3\2\2\2d\27\3\2\2\2ef\7\4\2\2fg\7\"\2\2")
        buf.write("gj\5\30\r\2hj\7\4\2\2ie\3\2\2\2ih\3\2\2\2j\31\3\2\2\2")
        buf.write("kl\7\5\2\2lm\7\"\2\2mp\5\32\16\2np\7\5\2\2ok\3\2\2\2o")
        buf.write("n\3\2\2\2p\33\3\2\2\2qr\7\7\2\2rs\7\"\2\2sv\5\34\17\2")
        buf.write("tv\7\7\2\2uq\3\2\2\2ut\3\2\2\2v\35\3\2\2\2wz\7\33\2\2")
        buf.write("xz\3\2\2\2yw\3\2\2\2yx\3\2\2\2z}\3\2\2\2{~\7\20\2\2|~")
        buf.write("\3\2\2\2}{\3\2\2\2}|\3\2\2\2~\177\3\2\2\2\177\u0080\7")
        buf.write(",\2\2\u0080\u0081\7%\2\2\u0081\u0082\5\b\5\2\u0082\37")
        buf.write("\3\2\2\2\u0083\u0084\7,\2\2\u0084\u0085\7%\2\2\u0085\u0086")
        buf.write("\7\26\2\2\u0086\u0087\5*\26\2\u0087\u0088\7&\2\2\u0088")
        buf.write("\u0089\5&\24\2\u0089\u008a\7\'\2\2\u008a\u008b\5\"\22")
        buf.write("\2\u008b!\3\2\2\2\u008c\u008d\7\33\2\2\u008d\u0090\5$")
        buf.write("\23\2\u008e\u0090\3\2\2\2\u008f\u008c\3\2\2\2\u008f\u008e")
        buf.write("\3\2\2\2\u0090#\3\2\2\2\u0091\u0092\7,\2\2\u0092%\3\2")
        buf.write("\2\2\u0093\u0096\5(\25\2\u0094\u0096\3\2\2\2\u0095\u0093")
        buf.write("\3\2\2\2\u0095\u0094\3\2\2\2\u0096\'\3\2\2\2\u0097\u0098")
        buf.write("\5\36\20\2\u0098\u0099\7\"\2\2\u0099\u009a\5(\25\2\u009a")
        buf.write("\u009d\3\2\2\2\u009b\u009d\5\36\20\2\u009c\u0097\3\2\2")
        buf.write("\2\u009c\u009b\3\2\2\2\u009d)\3\2\2\2\u009e\u009f\t\3")
        buf.write("\2\2\u009f+\3\2\2\2\21/\66CIY_ciouy}\u008f\u0095\u009c")
        return buf.getvalue()


class MT22Parser ( Parser ):

    grammarFileName = "MT22.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'auto'", "'break'", 
                     "'integer'", "'void'", "'array'", "'float'", "'return'", 
                     "'out'", "'boolean'", "'for'", "'string'", "'continue'", 
                     "'do'", "'function'", "'of'", "'else'", "'if'", "'while'", 
                     "'inherit'", "'+'", "'-'", "'*'", "'/'", "'%'", "'.'", 
                     "','", "';'", "'='", "':'", "'('", "')'", "'['", "']'", 
                     "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "COMMENT", "INTEGER_LIT", "FLOAT_LIT", 
                      "BOOLEAN_LIT", "STRING_LIT", "ARRAY_LIT", "AUTO", 
                      "BREAK", "INTEGER", "VOID", "ARRAY", "FLOAT", "RETURN", 
                      "OUT", "BOOLEAN", "FOR", "STRING", "CONTINUE", "DO", 
                      "FUNCTION", "OF", "ELSE", "IF", "WHILE", "INHERIT", 
                      "PLUS", "MINUS", "MUL", "DIV", "MOD", "PERIOD", "COMMA", 
                      "SEMI", "EQUAL", "COLON", "LB", "RB", "LSB", "RSB", 
                      "LCB", "RCB", "IDENTIFIER", "WS", "UNCLOSE_STRING", 
                      "ILLEGAL_ESCAPE", "ERROR_CHAR" ]

    RULE_program = 0
    RULE_decls = 1
    RULE_array_type = 2
    RULE_element_type = 3
    RULE_dimesion = 4
    RULE_dimesion_type_int = 5
    RULE_dimesion_type_float = 6
    RULE_variable_decl = 7
    RULE_equal_exp = 8
    RULE_identifier_list = 9
    RULE_expression_list = 10
    RULE_exp_list_type_int = 11
    RULE_exp_list_type_float = 12
    RULE_exp_list_type_string = 13
    RULE_parameter = 14
    RULE_function_decl = 15
    RULE_inheritance = 16
    RULE_function_name = 17
    RULE_paramter_list = 18
    RULE_paramter_list_term = 19
    RULE_return_type = 20

    ruleNames =  [ "program", "decls", "array_type", "element_type", "dimesion", 
                   "dimesion_type_int", "dimesion_type_float", "variable_decl", 
                   "equal_exp", "identifier_list", "expression_list", "exp_list_type_int", 
                   "exp_list_type_float", "exp_list_type_string", "parameter", 
                   "function_decl", "inheritance", "function_name", "paramter_list", 
                   "paramter_list_term", "return_type" ]

    EOF = Token.EOF
    COMMENT=1
    INTEGER_LIT=2
    FLOAT_LIT=3
    BOOLEAN_LIT=4
    STRING_LIT=5
    ARRAY_LIT=6
    AUTO=7
    BREAK=8
    INTEGER=9
    VOID=10
    ARRAY=11
    FLOAT=12
    RETURN=13
    OUT=14
    BOOLEAN=15
    FOR=16
    STRING=17
    CONTINUE=18
    DO=19
    FUNCTION=20
    OF=21
    ELSE=22
    IF=23
    WHILE=24
    INHERIT=25
    PLUS=26
    MINUS=27
    MUL=28
    DIV=29
    MOD=30
    PERIOD=31
    COMMA=32
    SEMI=33
    EQUAL=34
    COLON=35
    LB=36
    RB=37
    LSB=38
    RSB=39
    LCB=40
    RCB=41
    IDENTIFIER=42
    WS=43
    UNCLOSE_STRING=44
    ILLEGAL_ESCAPE=45
    ERROR_CHAR=46

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(MT22Parser.EOF, 0)

        def decls(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MT22Parser.DeclsContext)
            else:
                return self.getTypedRuleContext(MT22Parser.DeclsContext,i)


        def getRuleIndex(self):
            return MT22Parser.RULE_program




    def program(self):

        localctx = MT22Parser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 43 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 42
                self.decls()
                self.state = 45 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==MT22Parser.ARRAY or _la==MT22Parser.IDENTIFIER):
                    break

            self.state = 47
            self.match(MT22Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def array_type(self):
            return self.getTypedRuleContext(MT22Parser.Array_typeContext,0)


        def variable_decl(self):
            return self.getTypedRuleContext(MT22Parser.Variable_declContext,0)


        def function_decl(self):
            return self.getTypedRuleContext(MT22Parser.Function_declContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_decls




    def decls(self):

        localctx = MT22Parser.DeclsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_decls)
        try:
            self.state = 52
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 49
                self.array_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 50
                self.variable_decl()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 51
                self.function_decl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(MT22Parser.ARRAY, 0)

        def LSB(self):
            return self.getToken(MT22Parser.LSB, 0)

        def dimesion(self):
            return self.getTypedRuleContext(MT22Parser.DimesionContext,0)


        def RSB(self):
            return self.getToken(MT22Parser.RSB, 0)

        def OF(self):
            return self.getToken(MT22Parser.OF, 0)

        def element_type(self):
            return self.getTypedRuleContext(MT22Parser.Element_typeContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_array_type




    def array_type(self):

        localctx = MT22Parser.Array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_array_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(MT22Parser.ARRAY)
            self.state = 55
            self.match(MT22Parser.LSB)
            self.state = 56
            self.dimesion()
            self.state = 57
            self.match(MT22Parser.RSB)
            self.state = 58
            self.match(MT22Parser.OF)
            self.state = 59
            self.element_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Element_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(MT22Parser.INTEGER, 0)

        def FLOAT(self):
            return self.getToken(MT22Parser.FLOAT, 0)

        def BOOLEAN(self):
            return self.getToken(MT22Parser.BOOLEAN, 0)

        def STRING(self):
            return self.getToken(MT22Parser.STRING, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_element_type




    def element_type(self):

        localctx = MT22Parser.Element_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_element_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MT22Parser.INTEGER) | (1 << MT22Parser.FLOAT) | (1 << MT22Parser.BOOLEAN) | (1 << MT22Parser.STRING))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimesionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dimesion_type_int(self):
            return self.getTypedRuleContext(MT22Parser.Dimesion_type_intContext,0)


        def dimesion_type_float(self):
            return self.getTypedRuleContext(MT22Parser.Dimesion_type_floatContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_dimesion




    def dimesion(self):

        localctx = MT22Parser.DimesionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_dimesion)
        try:
            self.state = 65
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.INTEGER_LIT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 63
                self.dimesion_type_int()
                pass
            elif token in [MT22Parser.FLOAT_LIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 64
                self.dimesion_type_float()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dimesion_type_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_LIT(self):
            return self.getToken(MT22Parser.INTEGER_LIT, 0)

        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def dimesion_type_int(self):
            return self.getTypedRuleContext(MT22Parser.Dimesion_type_intContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_dimesion_type_int




    def dimesion_type_int(self):

        localctx = MT22Parser.Dimesion_type_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_dimesion_type_int)
        try:
            self.state = 71
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 67
                self.match(MT22Parser.INTEGER_LIT)
                self.state = 68
                self.match(MT22Parser.COMMA)
                self.state = 69
                self.dimesion_type_int()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 70
                self.match(MT22Parser.INTEGER_LIT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dimesion_type_floatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT_LIT(self, i:int=None):
            if i is None:
                return self.getTokens(MT22Parser.FLOAT_LIT)
            else:
                return self.getToken(MT22Parser.FLOAT_LIT, i)

        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def dimesion_type_float(self):
            return self.getTypedRuleContext(MT22Parser.Dimesion_type_floatContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_dimesion_type_float




    def dimesion_type_float(self):

        localctx = MT22Parser.Dimesion_type_floatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_dimesion_type_float)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.match(MT22Parser.FLOAT_LIT)
            self.state = 74
            self.match(MT22Parser.COMMA)
            self.state = 75
            self.dimesion_type_float()
            self.state = 76
            self.match(MT22Parser.FLOAT_LIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(MT22Parser.Identifier_listContext,0)


        def COLON(self):
            return self.getToken(MT22Parser.COLON, 0)

        def element_type(self):
            return self.getTypedRuleContext(MT22Parser.Element_typeContext,0)


        def equal_exp(self):
            return self.getTypedRuleContext(MT22Parser.Equal_expContext,0)


        def SEMI(self):
            return self.getToken(MT22Parser.SEMI, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_variable_decl




    def variable_decl(self):

        localctx = MT22Parser.Variable_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_variable_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.identifier_list()
            self.state = 79
            self.match(MT22Parser.COLON)
            self.state = 80
            self.element_type()
            self.state = 81
            self.equal_exp()
            self.state = 82
            self.match(MT22Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Equal_expContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(MT22Parser.EQUAL, 0)

        def expression_list(self):
            return self.getTypedRuleContext(MT22Parser.Expression_listContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_equal_exp




    def equal_exp(self):

        localctx = MT22Parser.Equal_expContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_equal_exp)
        try:
            self.state = 87
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.EQUAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 84
                self.match(MT22Parser.EQUAL)
                self.state = 85
                self.expression_list()
                pass
            elif token in [MT22Parser.SEMI]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Identifier_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(MT22Parser.IDENTIFIER, 0)

        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(MT22Parser.Identifier_listContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_identifier_list




    def identifier_list(self):

        localctx = MT22Parser.Identifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_identifier_list)
        try:
            self.state = 93
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 89
                self.match(MT22Parser.IDENTIFIER)
                self.state = 90
                self.match(MT22Parser.COMMA)
                self.state = 91
                self.identifier_list()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 92
                self.match(MT22Parser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expression_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exp_list_type_int(self):
            return self.getTypedRuleContext(MT22Parser.Exp_list_type_intContext,0)


        def exp_list_type_float(self):
            return self.getTypedRuleContext(MT22Parser.Exp_list_type_floatContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_expression_list




    def expression_list(self):

        localctx = MT22Parser.Expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression_list)
        try:
            self.state = 97
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.INTEGER_LIT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                self.exp_list_type_int()
                pass
            elif token in [MT22Parser.FLOAT_LIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 96
                self.exp_list_type_float()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exp_list_type_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_LIT(self):
            return self.getToken(MT22Parser.INTEGER_LIT, 0)

        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def exp_list_type_int(self):
            return self.getTypedRuleContext(MT22Parser.Exp_list_type_intContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_exp_list_type_int




    def exp_list_type_int(self):

        localctx = MT22Parser.Exp_list_type_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_exp_list_type_int)
        try:
            self.state = 103
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.match(MT22Parser.INTEGER_LIT)
                self.state = 100
                self.match(MT22Parser.COMMA)
                self.state = 101
                self.exp_list_type_int()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.match(MT22Parser.INTEGER_LIT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exp_list_type_floatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT_LIT(self):
            return self.getToken(MT22Parser.FLOAT_LIT, 0)

        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def exp_list_type_float(self):
            return self.getTypedRuleContext(MT22Parser.Exp_list_type_floatContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_exp_list_type_float




    def exp_list_type_float(self):

        localctx = MT22Parser.Exp_list_type_floatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_exp_list_type_float)
        try:
            self.state = 109
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 105
                self.match(MT22Parser.FLOAT_LIT)
                self.state = 106
                self.match(MT22Parser.COMMA)
                self.state = 107
                self.exp_list_type_float()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 108
                self.match(MT22Parser.FLOAT_LIT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exp_list_type_stringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LIT(self):
            return self.getToken(MT22Parser.STRING_LIT, 0)

        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def exp_list_type_string(self):
            return self.getTypedRuleContext(MT22Parser.Exp_list_type_stringContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_exp_list_type_string




    def exp_list_type_string(self):

        localctx = MT22Parser.Exp_list_type_stringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_exp_list_type_string)
        try:
            self.state = 115
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 111
                self.match(MT22Parser.STRING_LIT)
                self.state = 112
                self.match(MT22Parser.COMMA)
                self.state = 113
                self.exp_list_type_string()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 114
                self.match(MT22Parser.STRING_LIT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(MT22Parser.IDENTIFIER, 0)

        def COLON(self):
            return self.getToken(MT22Parser.COLON, 0)

        def element_type(self):
            return self.getTypedRuleContext(MT22Parser.Element_typeContext,0)


        def INHERIT(self):
            return self.getToken(MT22Parser.INHERIT, 0)

        def OUT(self):
            return self.getToken(MT22Parser.OUT, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_parameter




    def parameter(self):

        localctx = MT22Parser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.INHERIT]:
                self.state = 117
                self.match(MT22Parser.INHERIT)
                pass
            elif token in [MT22Parser.OUT, MT22Parser.IDENTIFIER]:
                pass
            else:
                raise NoViableAltException(self)

            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.OUT]:
                self.state = 121
                self.match(MT22Parser.OUT)
                pass
            elif token in [MT22Parser.IDENTIFIER]:
                pass
            else:
                raise NoViableAltException(self)

            self.state = 125
            self.match(MT22Parser.IDENTIFIER)
            self.state = 126
            self.match(MT22Parser.COLON)
            self.state = 127
            self.element_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(MT22Parser.IDENTIFIER, 0)

        def COLON(self):
            return self.getToken(MT22Parser.COLON, 0)

        def FUNCTION(self):
            return self.getToken(MT22Parser.FUNCTION, 0)

        def return_type(self):
            return self.getTypedRuleContext(MT22Parser.Return_typeContext,0)


        def LB(self):
            return self.getToken(MT22Parser.LB, 0)

        def paramter_list(self):
            return self.getTypedRuleContext(MT22Parser.Paramter_listContext,0)


        def RB(self):
            return self.getToken(MT22Parser.RB, 0)

        def inheritance(self):
            return self.getTypedRuleContext(MT22Parser.InheritanceContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_function_decl




    def function_decl(self):

        localctx = MT22Parser.Function_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_function_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(MT22Parser.IDENTIFIER)
            self.state = 130
            self.match(MT22Parser.COLON)
            self.state = 131
            self.match(MT22Parser.FUNCTION)
            self.state = 132
            self.return_type()
            self.state = 133
            self.match(MT22Parser.LB)
            self.state = 134
            self.paramter_list()
            self.state = 135
            self.match(MT22Parser.RB)
            self.state = 136
            self.inheritance()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InheritanceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INHERIT(self):
            return self.getToken(MT22Parser.INHERIT, 0)

        def function_name(self):
            return self.getTypedRuleContext(MT22Parser.Function_nameContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_inheritance




    def inheritance(self):

        localctx = MT22Parser.InheritanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_inheritance)
        try:
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.INHERIT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 138
                self.match(MT22Parser.INHERIT)
                self.state = 139
                self.function_name()
                pass
            elif token in [MT22Parser.EOF, MT22Parser.ARRAY, MT22Parser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(MT22Parser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_function_name




    def function_name(self):

        localctx = MT22Parser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(MT22Parser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paramter_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramter_list_term(self):
            return self.getTypedRuleContext(MT22Parser.Paramter_list_termContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_paramter_list




    def paramter_list(self):

        localctx = MT22Parser.Paramter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_paramter_list)
        try:
            self.state = 147
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [MT22Parser.OUT, MT22Parser.INHERIT, MT22Parser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 145
                self.paramter_list_term()
                pass
            elif token in [MT22Parser.RB]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Paramter_list_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self):
            return self.getTypedRuleContext(MT22Parser.ParameterContext,0)


        def COMMA(self):
            return self.getToken(MT22Parser.COMMA, 0)

        def paramter_list_term(self):
            return self.getTypedRuleContext(MT22Parser.Paramter_list_termContext,0)


        def getRuleIndex(self):
            return MT22Parser.RULE_paramter_list_term




    def paramter_list_term(self):

        localctx = MT22Parser.Paramter_list_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_paramter_list_term)
        try:
            self.state = 154
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 149
                self.parameter()
                self.state = 150
                self.match(MT22Parser.COMMA)
                self.state = 151
                self.paramter_list_term()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 153
                self.parameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Return_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(MT22Parser.INTEGER, 0)

        def FLOAT(self):
            return self.getToken(MT22Parser.FLOAT, 0)

        def BOOLEAN(self):
            return self.getToken(MT22Parser.BOOLEAN, 0)

        def STRING(self):
            return self.getToken(MT22Parser.STRING, 0)

        def VOID(self):
            return self.getToken(MT22Parser.VOID, 0)

        def AUTO(self):
            return self.getToken(MT22Parser.AUTO, 0)

        def getRuleIndex(self):
            return MT22Parser.RULE_return_type




    def return_type(self):

        localctx = MT22Parser.Return_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_return_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MT22Parser.AUTO) | (1 << MT22Parser.INTEGER) | (1 << MT22Parser.VOID) | (1 << MT22Parser.FLOAT) | (1 << MT22Parser.BOOLEAN) | (1 << MT22Parser.STRING))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





